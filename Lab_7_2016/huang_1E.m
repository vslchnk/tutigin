 %Эмпирическая модовая декомпозиция Хуанга
 %исходная функция задана аналитически и близка к линейнонарастающей
 %определение степени очистки от шумов производится
 %путем сравнения отфильтрованного сигнала с исходным
 clear all;
N=2401;%количество точек
d=0.005;%шаг изменения переменной time
M=(N-1)*d;%
Q=0.1;%уровень шума в долях СКО (для гарм.сигнала.1-й вид сигнала)
%Q=4;%уровень шума в долях СКО (для полинома.2-й вид сигнала)
%Q=4;%уровень шума в долях СКО (для предварительно очищенных от шума данных
%из файла 90.xls.3-й вид сигнала)
KF=6;
KP1=5;
KP2=7;

  noise=rand(N);%генерация массива нормально распределенного шума
% % noise=wgn(kt,1,0);%генерация массива белого Гауссова шума
for k=1:N % генерация сигнала и шума
 s(k) = sin(2*pi*KP1*k/N);%+ sin(2*pi*KP2*k/N);%1-й вид сигнала
% x(k)=64*(k-1)/N; %2-й вид сигнала
% s(k)=p1*x(k)^4+p2*x(k)^3+p3*x(k)^2+p4*x(k)+p5;%2-й вид сигнала
q(k)=Q*noise(k); %СКО шума равно Q
x(k)=s(k)+q(k); % суммирование сигнала и шума
end
DS=max(s)-min(s);

%  filename = 'LAB_90.xls';%3-й вид сигнала
%  x = xlsread(filename);%3-й вид сигнала
  figure
  plot(x);
  title ('original signal')
 
%Генерация модельного нестационарного сигнала
 time = 0:d:M;
% f1 = 4*sin(2*time);
% f2 = -3*sin(5*(time));

%f = f1(1:N) + f2(1:N)+shum*noise(1:N);
f=x(1:N);
% f(N) = f(N-1);
 figure
plot(f);
title('Модельный сигнал');

%Обнуление матрицы остатков

r = zeros(10,1+M/d);
r(1,:) = f;%Операция создания 1-й строки матрицы остатков r из массива f
%первая строка матрицы остатков равна самому модельному сигналу

%ПОЛУЧЕНИЕ ФУНКЦИЙ РАЗЛОЖЕНИЯ
for ii = 1:10 %10 - максимальное количество функций разложения IMF
    h = r(ii,:);%r(ii,:)-операция выделения строки ii из матрицы r  
    maxLastCount = -10;
    for i = 1:2400 % 30 - максимальное количество экстремумов
         [ymax,imax,ymin,imin]  = extrema(h);%нахождение массивов локальных максимумов
        %и минимумов с помощью стандартной функции extrema, имеющейся в MATLAB
        if((length(imax) < 2) || (length(imin) < 2))
            break;
        end;
       
        kUp = spline(time(imax),ymax,time);%сплайн-интерполяция локальных максимумов
        kDown =  spline(time(imin),ymin,time);%сплайн-интерполяция локальных минимумов
        kMean = (kUp + kDown)/2;
        h = h - kMean;
        [one, maxCount] = size(ymax);
        if(abs(maxCount - maxLastCount) < 4) 
            break; 
        end;
        maxLastCount = maxCount;
    end;
    c(ii,:) = h;  
      %*************************************************************
    %Начало фрагмента формирования искусственных экстремумов
    %Следующие 6 строк программы искусственно формируют по два экстремума
    %в числовых массивах IMF
    %(по одному масимуму и одному минимуму) в начале и в конце массива
    %амплитуды экстремумов могут мало отличаться от текущих значений 
    %ближайших элементов функций IMF
    %Здесь отличие задано на 10% от текущего значения. В общем случае 
    %процент отличия должен зависеть от уровня шума в функции IMF 
    c(ii,1)=c(ii,2);%1-ый элемент массива Cii устанавливается равным 2-му 
    c(ii,2)=c(ii,3)+0.1*abs(c(ii,3));%2-ой элемент массива Cii равен 3-му + 10% от модуля 3-го
    c(ii,3)=c(ii,4)-0.1*abs(c(ii,4));%3-ий элемент массива Cii равен 4-му минус 10% от модуля 4-го
     
    c(ii,N)=c(ii,N-1); %N-й элемент массива Cii устанавливается равным N-1-му
    c(ii,N-2)=c(ii,N-3)+0.1*abs(c(ii,N-3)); %N-2-й элемент массива Cii равен N-3-му +10% от модуля N-3-го
    c(ii,N-3)=c(ii,N-4)-0.1*abs(c(ii,N-4)) ; %N-3-й элемент массива Cii N-4-му минус 10% от модуля N-4-го    
    %Конец фрагмента формирования искусственных экстремумов
    %******************************************************************
    r(ii + 1,:) = r(ii,:) - c(ii,:); 
end;
i=N;
%Вывод функций разложения IMF
subplot (8, 1,1);
plot(c(1,:));title('IMF_1');subplot(8,1,2);
 cc(1)=mean(c(1,:));
plot(c(2,:));
 cc(2)=mean(c(2,:));title('IMF_2');subplot(8,1,3);
plot(c(3,:));title('IMF_3');subplot(8,1,4);
 cc(3)=mean(c(3,:));
plot(c(4,:));title('IMF_4');subplot(8,1,5);
 cc(4)=mean(c(4,:));
plot(c(5,:));title('IMF_5');subplot(8,1,6);
 cc(5)=mean(c(5,:));
plot(c(6,:));title('IMF_6');subplot(8,1,7);
 cc(6)=mean(c(6,:));
plot(c(7,:));
cc(7)=mean(c(7,:));title('IMF_7');

C1 = zeros(1,1+M/d);
%следующие три строки - только для чтения из файла
f = zeros(1,1+M/d);
i=1:1+M/d;
f(i)=x(i);

% Пример использования разложения Хуанга для фильтрации шумов
% Первая, а, может быть, и вторая и третья (как в данном случае)
% содержат наиболее высокочастотные составляющие сигнала
% К таким наиболее высокочастотным составляющим относится шум
% Поэтому суммируются те функций разложения Хуанга, 
% которые  относятся к шумовым,
% Последующее вычитание суммы шумовых IMF из исходного сигнала
%обеспечивает очистку сигнала от шумов
threshold=abs(cc(1))*5 %порог отсеивания
%for i = 1:KF-1  %Суммирование только тех IMF, которые  являются шумовыми
for i = 1:3     
     bsmean(i)=abs(cc(i)); %для контроля за отсеиванием. 
    if (abs(cc(i))<threshold) %!!! условие того, что IMF  является шумовой     
       C1=C1+c(i,:);%!!!накапливаем шумовые  функции IMF
        ki(i)=i;%для контроля за отсеиванием. 
       aabs=abs(cc(i));%для контроля за отсеиванием.      
   end
end 
kki=ki

bbs=bsmean %для контроля за отсеиванием. 
i=1:N;
f1(i)=f(i)-C1(i);%исходный зашумленный сигнал за вычетом шумовых IMF
%f1(i)=r(kki,i);
figure
plot(i,f(i),'r-');
title('Исходный зашумленный сигнал');
 hold on;
%figure
plot(i,f1(i));
title('Отфильтрованный сигнал');
hold off;

% Следующий блок программы комментируется если зашумленные
% данные берутся из файла ( этом случаев нет возможности выделить
% чистый незашумленный сигнал s)
i=1:N;
 for i=1:N
     DZ(i)=f1(i)-s(i);%уровень зашумления в сигнале после фильтра  
 end   
 SKO=std(DZ)
 KSKO=Q/SKO

pause;
close all;
clear;


