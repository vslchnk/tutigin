 %Эмпирическая модовая декомпозиция Хуанга. 
 %Используется для  очистки сигналов от шумов 
 
clc;%очистка Command Window
N=2401;%количество точек
d=0.005;%шаг изменения переменной time
M=(N-1)*d;%
time = 0:d:M;
Q=0.2;%уровень шума в долях СКО 
NF=3;%кол-во функций разложения, содержащих шум (NF=1..3)
KP1=5;%кол-во периодов первого сигнала
KP2=7;%кол-во периодов второго сигнала

  noise=rand(N);%генерация массива нормально распределенного шума
% noise=wgn(kt,1,0);%генерация массива белого Гауссова шума
for k=1:N % генерация гармонического сигнала 
s(k) = sin(2*pi*KP1*k/N)+ sin(2*pi*KP2*k/N);%1-й вид сигнала
f(k)=s(k)+Q*noise(k); % суммирование сигнала и шума
end
%Генерация  нестационарного сигнала 
% s = 4*sin(10*time.*time./100.0);
% f = s(1:N)+ Q*noise(1:N);
% Чтение  сигнала из файла LAB_7.xls
%  filename = 'LAB_90.xls';%3-й вид сигнала
%  x = xlsread(filename);%3-й вид сигнала
% f = x(1:N);
% f(N) = f(N-1);
% f = zeros(1,1+M/d);
% i=1:1+M/d;
% f(i)=x(i);
i=1:N;
figure
plot(i,f(i));
title ('Исходный сигнал')

%Обнуление матрицы остатков
r = zeros(10,1+M/d);
r(1,:) = f;%Операция создания 1-й строки матрицы остатков r из массива f
%первая строка матрицы остатков равна самому модельному сигналу

%ПОЛУЧЕНИЕ ФУНКЦИЙ РАЗЛОЖЕНИЯ
for j = 1:10 %10 - максимальное количество функций разложения IMF
    h = r(j,:);%r(j,:)-операция выделения строки j из матрицы r  
    maxLastCount = -10;
    for i = 1:N % N - максимальное количество экстремумов
         [ymax,imax,ymin,imin]  = extrema(h);%нахождение массивов локальных максимумов
        %и минимумов с помощью стандартной функции extrema, имеющейся в MATLAB
        if((length(imax) < 2) || (length(imin) < 2))
            break;
        end;       
        kUp = spline(time(imax),ymax,time);%сплайн-интерполяция локальных максимумов
        kDown =  spline(time(imin),ymin,time);%сплайн-интерполяция локальных минимумов
        kMean = (kUp + kDown)/2;
        h = h - kMean;
        [one, maxCount] = size(ymax);
        if(abs(maxCount - maxLastCount) < 4) 
            break; 
        end;
        maxLastCount = maxCount;
    end;
    c(j,:) = h;  
    
%Формирование искусственных экстремумов в начале и в конце массива    
c(j,1)=c(j,2);%1-ый элемент массива Cj устанавливается равным 2-му 
c(j,2)=c(j,3)+0.1*abs(c(j,3));%2-ой элемент массива Cj равен 3-му + 10% от модуля 3-го
c(j,3)=c(j,4)-0.1*abs(c(j,4));%3-ий элемент массива Cj равен 4-му минус 10% от модуля 4-го     
c(j,N)=c(j,N-1); %N-й элемент массива Cj устанавливается равным N-1-му
c(j,N-2)=c(j,N-3)+0.1*abs(c(j,N-3)); %N-2-й элемент массива Cj равен N-3-му +10% от модуля N-3-го
c(j,N-3)=c(j,N-4)-0.1*abs(c(j,N-4)) ; %N-3-й элемент массива Cj N-4-му минус 10% от модуля N-4-го    

r(j + 1,:) = r(j,:) - c(j,:); 
end;
i=N;
%Вывод функций разложения IMF
figure
subplot (8, 1,1);
plot(c(1,:));title('IMF_1');subplot(8,1,2); 
plot(c(2,:));title('IMF_2');subplot(8,1,3);
plot(c(3,:));title('IMF_3');subplot(8,1,4);
plot(c(4,:));title('IMF_4');subplot(8,1,5); 
plot(c(5,:));title('IMF_5');subplot(8,1,6); 
plot(c(6,:));title('IMF_6');subplot(8,1,7);
plot(c(7,:));title('IMF_7');

%Вывод остатков
% figure; plot(r(1,:)); title('Остаток_1');
% figure;plot(r(2,:));title('Остаток_2');
% figure;plot(r(3,:));title('Остаток_3');
% figure;plot(r(4,:));title('Остаток_4');
% figure;plot(r(5,:));title('Остаток_5');
% figure;plot(r(6,:));title('Остаток_6');
% figure;plot(r(7,:));title('Остаток_7');
C1 = zeros(1,1+round(M/d));

%Суммирование функций разложения, содержащих только шум
for i = 1:NF          
       C1=C1+c(i,:);%накопление шумовых функций IMF
end 
i=1:N;
f1(i)=f(i)-C1(i);%исходный зашумленный сигнал за вычетом шумовых IMF

% figure;plot(i,f(i),'r-');
% title('Исходный зашумленный сигнал');
% hold on;
figure
plot(i,f1(i));
title('Отфильтрованный сигнал');
%hold off;

% Следующий блок программы комментируется, если зашумленные
% данные берутся из файла (в этом случаев 
% чистый незашумленный сигнал s неизвестен)
 for i=1:N
     DZ(i)=f1(i)-s(i);%уровень зашумления в сигнале после 
     %вычитания функций разложения, содержащих только шум
 end   
 SKO=std(DZ)%СКО полной погрешности
 KSKO=Q/SKO %коэффициент подавления шума

pause;
close all;
clear;


